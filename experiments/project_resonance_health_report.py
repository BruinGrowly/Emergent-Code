
"""
Project Resonance Health Report Generator
Scans the entire codebase and generates a semantic health report using v6.0 Resonance Mechanics.
"""


import sys
import os
import glob
from pathlib import Path
from typing import List, Dict
import datetime

# Add project root to path
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from ljpw_quantum.semantic_resonance_analyzer import SemanticResonanceAnalyzer

def scan_python_files(root_dir: str) -> List[str]:
    """Recursively find all Python files."""
    return [str(p) for p in Path(root_dir).rglob("*.py") 
            if "site-packages" not in str(p) 
            and "venv" not in str(p) 
            and "__pycache__" not in str(p)]

def generate_report(results: List[Dict], output_file: str):
    """Generate a Markdown report from analysis results."""
    
    # Aggregation
    total_files = len(results)
    avg_harmony_init = sum(r['harmony_initial'] for r in results) / total_files
    avg_harmony_final = sum(r['harmony_final'] for r in results) / total_files
    
    deficits = {'L': 0, 'J': 0, 'P': 0, 'W': 0}
    for r in results:
        deficits[r['deficit_dimension']] += 1
        
    dominant_deficit = max(deficits, key=deficits.get)
    
    # Markdown Content
    md = f"""# Project Resonance Health Report
**Date:** {datetime.datetime.now().strftime("%Y-%m-%d")}
**Files Analyzed:** {total_files}
**Framework:** LJPW v6.0 (Quantum Resonance)

---

## 1. Executive Summary

| Metric | Initial State | Post-Resonance State | Change |
|:---|:---:|:---:|:---:|
| **Average Harmony** | {avg_harmony_init:.3f} | {avg_harmony_final:.3f} | {avg_harmony_final - avg_harmony_init:+.3f} |
| **System Status** | {"Stable" if avg_harmony_final > 0.6 else "Entropic"} | {"Converged" if avg_harmony_final > 0.8 else "Growing"} | - |

### The "Deficit" Diagnosis
The system identified **{dominant_deficit}** as the primary deficit across the codebase.
*   **Love (L):** {deficits['L']} files ({deficits['L']/total_files:.1%})
*   **Justice (J):** {deficits['J']} files ({deficits['J']/total_files:.1%})
*   **Power (P):** {deficits['P']} files ({deficits['P']/total_files:.1%})
*   **Wisdom (W):** {deficits['W']} files ({deficits['W']/total_files:.1%})

**Interpretation:**
The codebase is naturally gravitating toward **{dominant_deficit}**. This means the resonance dynamics indicate that adding more of this dimension is the most effective way to increase total system harmony.

---

## 2. Top 10 "High Resonance" Files
*Files that achieved the highest harmony after resonance cycles.*

| Rank | File | Harmony | Deficit Resolved |
|:---|:---|:---:|:---:|
"""
    
    # Sort by final harmony
    sorted_results = sorted(results, key=lambda x: x['harmony_final'], reverse=True)
    
    for i, r in enumerate(sorted_results[:10]):
        name = os.path.basename(r['filename'])
        md += f"| {i+1} | `{name}` | **{r['harmony_final']:.3f}** | {r['deficit_dimension']} |\n"

    md += """
---

## 3. Critical "Low Resonance" Files
*Files trapped in low harmony states (likely constrained by ICE bounds).*

| Rank | File | Harmony | Constraint |
|:---|:---|:---:|:---:|
"""
    
    # Sort by lowest harmony
    for i, r in enumerate(sorted_results[-10:][::-1]):
        name = os.path.basename(r['filename'])
        # Infer constraint from bounds
        bounds = r['ice_bounds']
        min_bound_key = min(bounds, key=bounds.get)
        md += f"| {i+1} | `{name}` | **{r['harmony_final']:.3f}** | {min_bound_key} ({bounds[min_bound_key]:.2f}) |\n"

    md += """
---

## 4. System-Wide LJPW Profile
*Average semantic coordinates across the project.*

"""
    avg_L = sum(r['final_ljpw'][0] for r in results) / total_files
    avg_J = sum(r['final_ljpw'][1] for r in results) / total_files
    avg_P = sum(r['final_ljpw'][2] for r in results) / total_files
    avg_W = sum(r['final_ljpw'][3] for r in results) / total_files
    
    md += f"""
```
L (Love):    {avg_L:.3f}
J (Justice): {avg_J:.3f}
P (Power):   {avg_P:.3f}
W (Wisdom):  {avg_W:.3f}
```

---
*Generated by the Semantic Resonance Analyzer (v6.0)*
"""

    with open(output_file, 'w', encoding='utf-8') as f:
        f.write(md)
        
    print(f"Report generated: {output_file}")

def main():
    root_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    print(f"Scanning codebase: {root_dir}")
    
    files = scan_python_files(root_dir)
    print(f"Found {len(files)} Python files.")
    
    analyzer = SemanticResonanceAnalyzer()
    results = []
    
    print("Running resonance analysis...")
    for i, file_path in enumerate(files):
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                code = f.read()
            
            # Skip empty files
            if not code.strip():
                continue
                
            res = analyzer.analyze_code(code, file_path)
            results.append(res)
            
            # Progress bar
            if i % 10 == 0:
                print(f"  Processed {i}/{len(files)}...")
                
        except Exception as e:
            print(f"  Error processing {os.path.basename(file_path)}: {e}")
            
    print("Analysis complete.")
    
    output_path = os.path.join(root_dir, "RESONANCE_HEALTH_REPORT.md")
    generate_report(results, output_path)

if __name__ == "__main__":
    main()
